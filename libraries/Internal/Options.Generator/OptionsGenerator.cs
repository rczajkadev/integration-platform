using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Integrations.Options.Generator;

[Generator]
public sealed class OptionsGenerator : IIncrementalGenerator
{
    private const string OptionsSectionAttributeName = "Integrations.Options.OptionsSectionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var valueProvider = context.SyntaxProvider
            .CreateSyntaxProvider(Predicate, Transform)
            .Collect();

        context.RegisterSourceOutput(valueProvider, Execute);
    }

    private static bool Predicate(SyntaxNode node, CancellationToken _)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static SectionInfo? Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var declaredSymbol = context.SemanticModel.GetDeclaredSymbol(
            classDeclaration, cancellationToken: cancellationToken);

        if (declaredSymbol is not INamedTypeSymbol symbol)
            return null;

        var attribute = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == OptionsSectionAttributeName);

        if (attribute is null)
            return null;

        var sectionName = attribute.ConstructorArguments[0].Value as string;
        var propertyName = GetPropertyName(symbol.Name);
        var namespaceName = symbol.ContainingNamespace.ToDisplayString();
        return new SectionInfo(namespaceName, propertyName, sectionName ?? propertyName);
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<SectionInfo?> sections)
    {
        var groupedSections = sections
            .Where(s => s is not null)
            .Select(s => s!)
            .GroupBy(s => s.Namespace)
            .ToDictionary(g => g.Key, g => g.ToList());

        foreach (var group in groupedSections)
        {
            var namespaceName = group.Key;
            var namespaceSections = group.Value;
            var source = GenerateSource(namespaceName, namespaceSections);
            context.AddSource($"{namespaceName}.g.cs", source);
        }
    }

    private static string GenerateSource(string namespaceName, List<SectionInfo> sections)
    {
        var properties = GeneratePropertyBlock(sections);
        var assembly = typeof(OptionsGenerator).Assembly;
        var version = assembly.GetName().Version;

        return $$"""
            // <auto-generated/>
            using System.CodeDom.Compiler;
            using Microsoft.Extensions.Configuration;
            using Integrations.Options;

            namespace {{namespaceName}};

            [GeneratedCode("{{typeof(OptionsGenerator).FullName}}", "{{version}}")]
            internal sealed class Options(IConfiguration configuration) : OptionsBase(configuration)
            {
            {{properties.AddIndent(4)}}
            }
            """;
    }

    private static string GeneratePropertyBlock(IEnumerable<SectionInfo> sections)
    {
        var usedNames = new HashSet<string>();
        var lines = new List<string>();

        foreach (var section in sections.OrderBy(s => s.PropertyName))
        {
            var (_, propertyName, sectionName) = section;
            if (!usedNames.Add(propertyName)) continue;
            lines.Add($"public IConfigurationSection {propertyName} => Configuration.GetSection(\"{sectionName}\");");
        }

        return string.Join("\n", lines);
    }

    private static string GetPropertyName(string className)
    {
        const string suffix = "Options";

        return className.EndsWith(suffix)
            ? className.Substring(0, className.Length - suffix.Length)
            : className;
    }

    private sealed record SectionInfo(string Namespace, string PropertyName, string SectionName);
}
